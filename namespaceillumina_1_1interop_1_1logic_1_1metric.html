<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
 <!-- For Mobile Devices -->
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <!-- Loading Lato Font -->
 <link href='https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic' rel='stylesheet' type='text/css'>
 <!-- Loading Font Awesome -->
 <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
 <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
 <meta name="generator" content="Doxygen 1.8.11"/>
 <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-88338608-1', 'auto');
  ga('send', 'pageview');
</script>
 <title>illumina::interop::logic::metric Namespace Reference</title>
 <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
 <script type="text/javascript" src="dynsections.js"></script>
 <link href="doxygen.css" rel="stylesheet" type="text/css" />
 <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
 <link rel="stylesheet" href="bootstrap3/css/bootstrap.min.css">
 <link href="bootstrap3/css/sticky-footer-navbar.css" rel="stylesheet">
 <script src="bootstrap3/js/bootstrap.min.js"></script>
 <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body screen_capture_injected="true">
<nav class="navbar navbar-inverse" role="navigation">
 <div class="container">
  <div class="navbar-header">
   <a class="navbar-brand" href="https://www.illumina.com/"><img style='margin-top: -8px !important;height: 40px !important;' src='ILLUMINA_LOGO_RGB_new_200_45.png' /></a>
   <a class="navbar-brand">InterOp <span style="font-size: 10pt">v1.0.17</span>  </a>
  </div>
  <div class="collapse navbar-collapse">
   <!-- Left -->
   <ul class="nav navbar-nav adjust-right">
    <li><a href="https://github.com/Illumina/interop">Code</a></li>
    <li><a href="https://github.com/Illumina/interop/issues">Issues</a></li>
    <li><a href="https://github.com/Illumina/interop/releases/latest">Download</a></li>
   </ul>
  </div><!--/.nav-collapse -->
 </div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
 <div class="content" id="content">
  <div class="container">
   <div class="row">
    <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
     <div style="margin-bottom: 15px;">
      <!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="pages.html"><span>Index</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceillumina.html">illumina</a></li><li class="navelem"><a class="el" href="namespaceillumina_1_1interop.html">interop</a></li><li class="navelem"><a class="el" href="namespaceillumina_1_1interop_1_1logic.html">logic</a></li><li class="navelem"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html">metric</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">illumina::interop::logic::metric Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1logic_1_1metric_1_1metric__value.html">metric_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1logic_1_1metric_1_1metric__value_3_01model_1_1metrics_1_1corrected__intensity__metric_01_4.html">metric_value&lt; model::metrics::corrected_intensity_metric &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1logic_1_1metric_1_1metric__value_3_01model_1_1metrics_1_1error__metric_01_4.html">metric_value&lt; model::metrics::error_metric &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1logic_1_1metric_1_1metric__value_3_01model_1_1metrics_1_1extraction__metric_01_4.html">metric_value&lt; model::metrics::extraction_metric &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1logic_1_1metric_1_1metric__value_3_01model_1_1metrics_1_1phasing__metric_01_4.html">metric_value&lt; model::metrics::phasing_metric &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1logic_1_1metric_1_1metric__value_3_01model_1_1metrics_1_1q__by__lane__metric_01_4.html">metric_value&lt; model::metrics::q_by_lane_metric &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1logic_1_1metric_1_1metric__value_3_01model_1_1metrics_1_1q__collapsed__metric_01_4.html">metric_value&lt; model::metrics::q_collapsed_metric &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1logic_1_1metric_1_1metric__value_3_01model_1_1metrics_1_1tile__metric_01_4.html">metric_value&lt; model::metrics::tile_metric &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad706052df7c77ab706ea3329515da54d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ad706052df7c77ab706ea3329515da54d">populate_dynamic_phasing_metrics</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1phasing__metric.html">model::metrics::phasing_metric</a> &gt; &amp;phasing_metrics, const <a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1summary.html#a9269802b156d7d51dfd208503d114945">logic::summary::read_cycle_vector_t</a> &amp;cycle_to_read, <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1dynamic__phasing__metric.html">model::metrics::dynamic_phasing_metric</a> &gt; &amp;dynamic_phasing_metrics, <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1tile__metric.html">model::metrics::tile_metric</a> &gt; &amp;tile_metrics)</td></tr>
<tr class="separator:ad706052df7c77ab706ea3329515da54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab444318309ba347ab989d445d16e1ecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ab444318309ba347ab989d445d16e1ecd">copy_focus</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1extraction__metric.html">model::metrics::extraction_metric</a> &gt; &amp;metrics, float *focus_scores, const size_t channel, const size_t n)  throw (model::invalid_parameter, model::index_out_of_bounds_exception)</td></tr>
<tr class="separator:ab444318309ba347ab989d445d16e1ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eb9928846137fea7fe46618a25ee21"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a02eb9928846137fea7fe46618a25ee21"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a02eb9928846137fea7fe46618a25ee21">count_q_metric_bins</a> (I beg, I end)</td></tr>
<tr class="separator:a02eb9928846137fea7fe46618a25ee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5f6954b2b6fc9755742598b6f8e727"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a2a5f6954b2b6fc9755742598b6f8e727">count_q_metric_bins</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;metric_set)</td></tr>
<tr class="separator:a2a5f6954b2b6fc9755742598b6f8e727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab171ea60888d51b26dbf1214ea22a48c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ab171ea60888d51b26dbf1214ea22a48c">count_q_metric_bins</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;metric_set)</td></tr>
<tr class="separator:ab171ea60888d51b26dbf1214ea22a48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae441eb579cde2fc86024e389c5900fb4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ae441eb579cde2fc86024e389c5900fb4">count_q_metric_bins</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;)</td></tr>
<tr class="separator:ae441eb579cde2fc86024e389c5900fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4513418a65eaf84fc7af825475226f60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a4513418a65eaf84fc7af825475226f60">populate_cumulative_distribution</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)  throw ( model::index_out_of_bounds_exception )</td></tr>
<tr class="separator:a4513418a65eaf84fc7af825475226f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182afdbc60e4594926178858807969ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a182afdbc60e4594926178858807969ee">populate_cumulative_distribution</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)  throw ( model::index_out_of_bounds_exception )</td></tr>
<tr class="separator:a182afdbc60e4594926178858807969ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4436b3ce6fd74abddc7bf267fa23160e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a4436b3ce6fd74abddc7bf267fa23160e">populate_cumulative_distribution</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)  throw ( model::index_out_of_bounds_exception )</td></tr>
<tr class="separator:a4436b3ce6fd74abddc7bf267fa23160e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e529aedb5b3470bad05be4a673cd20"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a76e529aedb5b3470bad05be4a673cd20">count_legacy_q_score_bins</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:a76e529aedb5b3470bad05be4a673cd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d25d41b66e91ee21b67901188747d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ab3d25d41b66e91ee21b67901188747d6">requires_legacy_bins</a> (const size_t count)</td></tr>
<tr class="separator:ab3d25d41b66e91ee21b67901188747d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8809c6f0abb67743e6933ff198b71229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a8809c6f0abb67743e6933ff198b71229">populate_legacy_q_score_bins</a> (std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__score__bin.html">model::metrics::q_score_bin</a> &gt; &amp;q_score_bins, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#a849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument, const size_t count)</td></tr>
<tr class="separator:a8809c6f0abb67743e6933ff198b71229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e02d95ade6d725d946c69ef8d2e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a6e8e02d95ade6d725d946c69ef8d2e52">compress_q_metrics</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:a6e8e02d95ade6d725d946c69ef8d2e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5665e451c6219dee1129adad7b3612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a4b5665e451c6219dee1129adad7b3612">compress_q_metrics</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:a4b5665e451c6219dee1129adad7b3612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e84b12f05bac281a4131ec493f20a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a1e84b12f05bac281a4131ec493f20a51">populate_legacy_q_score_bins</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>, std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__score__bin.html">model::metrics::q_score_bin</a> &gt; &amp;q_score_bins, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#a849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument)</td></tr>
<tr class="separator:a1e84b12f05bac281a4131ec493f20a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42335973ac805f414847152f52578996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a42335973ac805f414847152f52578996">populate_legacy_q_score_bins</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>, std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__score__bin.html">model::metrics::q_score_bin</a> &gt; &amp;q_score_bins, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#a849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument)</td></tr>
<tr class="separator:a42335973ac805f414847152f52578996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8836306d7f51a31de926e5736be98647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a8836306d7f51a31de926e5736be98647">populate_legacy_q_score_bins</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>, std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__score__bin.html">model::metrics::q_score_bin</a> &gt; &amp;q_score_bins, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#a849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument)</td></tr>
<tr class="separator:a8836306d7f51a31de926e5736be98647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669a000cf564120ea406c24051d20995"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a669a000cf564120ea406c24051d20995">count_qvals</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:a669a000cf564120ea406c24051d20995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeda2bde2cfde0167de9d1e7c141b71f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#adeda2bde2cfde0167de9d1e7c141b71f">count_qvals</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:adeda2bde2cfde0167de9d1e7c141b71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c85426a1e7f771f552cd19d188f7aa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a27c85426a1e7f771f552cd19d188f7aa">count_qvals</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;)</td></tr>
<tr class="separator:a27c85426a1e7f771f552cd19d188f7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d47a4293dccdd4cc74335faf596f063"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a9d47a4293dccdd4cc74335faf596f063">is_compressed</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:a9d47a4293dccdd4cc74335faf596f063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7512321bc0c081a8e9610bcc5631de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#abf7512321bc0c081a8e9610bcc5631de">is_compressed</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:abf7512321bc0c081a8e9610bcc5631de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac916e8708ebdda85d212ce2631510f48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ac916e8708ebdda85d212ce2631510f48">is_compressed</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:ac916e8708ebdda85d212ce2631510f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0196a06bc3001748210a6d0c3fa96"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ac0e0196a06bc3001748210a6d0c3fa96">max_qval</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:ac0e0196a06bc3001748210a6d0c3fa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1739cce953b851ed2cc3b54d56afe4ea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a1739cce953b851ed2cc3b54d56afe4ea">max_qval</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:a1739cce953b851ed2cc3b54d56afe4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7fbdb67c0a6366326711706ec1c4eb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ade7fbdb67c0a6366326711706ec1c4eb">max_qval</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:ade7fbdb67c0a6366326711706ec1c4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef30dfc0ef9746b674661dff73df370"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#adef30dfc0ef9746b674661dff73df370">index_for_q_value</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>, const size_t qval)</td></tr>
<tr class="separator:adef30dfc0ef9746b674661dff73df370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc9916c30d3f620c2b48dc2909905e7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a1fc9916c30d3f620c2b48dc2909905e7">index_for_q_value</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>, const size_t qval)</td></tr>
<tr class="separator:a1fc9916c30d3f620c2b48dc2909905e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff702ee4fdc57b833be112716e1a4cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#aeff702ee4fdc57b833be112716e1a4cf">create_collapse_q_metrics</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;metric_set, <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;collapsed)</td></tr>
<tr class="separator:aeff702ee4fdc57b833be112716e1a4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485f78badd31f82b9a3e1c49e77b735c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a485f78badd31f82b9a3e1c49e77b735c">create_q_metrics_by_lane</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;metric_set, <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;bylane)  throw (model::index_out_of_bounds_exception)</td></tr>
<tr class="separator:a485f78badd31f82b9a3e1c49e77b735c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e50ecdfca3016a975969b28cfd08e7f"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a5e50ecdfca3016a975969b28cfd08e7f">lane_from_name</a> (const std::string &amp;tile_name)</td></tr>
<tr class="separator:a5e50ecdfca3016a975969b28cfd08e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbc3869d286655f0dc2c90fb2d85b04"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#abbbc3869d286655f0dc2c90fb2d85b04">tile_from_name</a> (const std::string &amp;tile_name)</td></tr>
<tr class="separator:abbbc3869d286655f0dc2c90fb2d85b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0664b929bb0697936655810a334a8ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ab0664b929bb0697936655810a334a8ef">tile_naming_method_from_metric</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1base__metric.html">model::metric_base::base_metric</a> &amp;metric)</td></tr>
<tr class="separator:ab0664b929bb0697936655810a334a8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d22d75ec1c26ebca73989574196a8b"><td class="memTemplParams" colspan="2">template&lt;class Metric &gt; </td></tr>
<tr class="memitem:ad9d22d75ec1c26ebca73989574196a8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ad9d22d75ec1c26ebca73989574196a8b">tile_naming_method_from_metric</a> (const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; Metric &gt; &amp;metric_set)</td></tr>
<tr class="separator:ad9d22d75ec1c26ebca73989574196a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6ff64f1c38a893a5abf1f7a1fa3dfe"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a7a6ff64f1c38a893a5abf1f7a1fa3dfe">number</a> (const ::uint32_t tile_id, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a>)</td></tr>
<tr class="separator:a7a6ff64f1c38a893a5abf1f7a1fa3dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c968c5fbff5bbcf12c937010cd4689"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ab1c968c5fbff5bbcf12c937010cd4689">section</a> (const ::uint32_t tile_id, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a> method)</td></tr>
<tr class="separator:ab1c968c5fbff5bbcf12c937010cd4689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de62d8ac1f534d0ac2ebcbc8eb3d0db"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a3de62d8ac1f534d0ac2ebcbc8eb3d0db">surface</a> (const ::uint32_t tile_id, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a> method)</td></tr>
<tr class="separator:a3de62d8ac1f534d0ac2ebcbc8eb3d0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb768910f86a9090a16bbc525c0ec7a"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a0bb768910f86a9090a16bbc525c0ec7a">swath</a> (const ::uint32_t tile_id, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a> method)</td></tr>
<tr class="separator:a0bb768910f86a9090a16bbc525c0ec7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5b47daadbc0fb8f4c32ad028195d2"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a38b5b47daadbc0fb8f4c32ad028195d2">physical_location_column</a> (const ::uint32_t tile_id, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a> method, const ::uint32_t swath_count, const bool all_surfaces)</td></tr>
<tr class="separator:a38b5b47daadbc0fb8f4c32ad028195d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1443cec18eab79d5a7732601adc4704c"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a1443cec18eab79d5a7732601adc4704c">physical_location_row</a> (const ::uint32_t tile_id, const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a> method, const ::uint32_t section_per_lane, const ::uint32_t tile_count)</td></tr>
<tr class="separator:a1443cec18eab79d5a7732601adc4704c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a77c902372cc9d1333afc8575e4e3f6"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a9a77c902372cc9d1333afc8575e4e3f6">physical_location_column</a> (const ::uint32_t tile_id, const <a class="el" href="classillumina_1_1interop_1_1model_1_1run_1_1flowcell__layout.html">model::run::flowcell_layout</a> &amp;layout, const bool all_surfaces)</td></tr>
<tr class="separator:a9a77c902372cc9d1333afc8575e4e3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d96d83b841a2eb24dcaa846903ac5f"><td class="memItemLeft" align="right" valign="top">inline::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a04d96d83b841a2eb24dcaa846903ac5f">physical_location_row</a> (const ::uint32_t tile_id, const <a class="el" href="classillumina_1_1interop_1_1model_1_1run_1_1flowcell__layout.html">model::run::flowcell_layout</a> &amp;layout)</td></tr>
<tr class="separator:a04d96d83b841a2eb24dcaa846903ac5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25602fa81b2c3b566b5a0acba2f1cd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#aa25602fa81b2c3b566b5a0acba2f1cd7">compute_linear_fit</a> (const std::vector&lt; float &gt; &amp;x_values, const std::vector&lt; float &gt; &amp;y_values, float &amp;slope, float &amp;offset, size_t sample_count=0)</td></tr>
<tr class="separator:aa25602fa81b2c3b566b5a0acba2f1cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2255099000b0748948892068219a41af"><td class="memTemplParams" colspan="2">template&lt;class QMetric &gt; </td></tr>
<tr class="memitem:a2255099000b0748948892068219a41af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#a2255099000b0748948892068219a41af">populate_cumulative_distribution_t</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; QMetric &gt; &amp;metric_set)  throw ( model::index_out_of_bounds_exception )</td></tr>
<tr class="separator:a2255099000b0748948892068219a41af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dc4803098a0ab5a4f7de067d31dfbf"><td class="memTemplParams" colspan="2">template&lt;class QMetric &gt; </td></tr>
<tr class="memitem:ac4dc4803098a0ab5a4f7de067d31dfbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1metric.html#ac4dc4803098a0ab5a4f7de067d31dfbf">compress_q_metrics_t</a> (<a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; QMetric &gt; &amp;<a class="el" href="q__metrics__test_8cpp.html#ae67c7f9b5f34e523f84fe9dd927c9893">q_metric_set</a>)</td></tr>
<tr class="separator:ac4dc4803098a0ab5a4f7de067d31dfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6e8e02d95ade6d725d946c69ef8d2e52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compress_q_metrics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compress the q-metric set using the bins in the header</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b5665e451c6219dee1129adad7b3612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compress_q_metrics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compress the q-metric set using the bins in the header</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4dc4803098a0ab5a4f7de067d31dfbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::metric::compress_q_metrics_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; QMetric &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compress the q-metric set using the bins in the header</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa25602fa81b2c3b566b5a0acba2f1cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::metric::compute_linear_fit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sample_count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the best fit line (slope + offset) given the points defined by (x_values[i], y_values[i])</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_values</td><td>X-values of the list of points </td></tr>
    <tr><td class="paramname">y_values</td><td>Y-values of the list of points </td></tr>
    <tr><td class="paramname">slope</td><td>slope of the best fit line (calculated by this function) </td></tr>
    <tr><td class="paramname">offset</td><td>offset of the best fit line (calculated by this function) </td></tr>
    <tr><td class="paramname">sample_count</td><td>number of weights to use for fitting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if linear fit could be computed, false if not </dd></dl>

</div>
</div>
<a class="anchor" id="ab444318309ba347ab989d445d16e1ecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy_focus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1extraction__metric.html">model::metrics::extraction_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>focus_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2">model::invalid_parameter,</td>
        </tr>
        <tr>
          <td align="right"></td><td></td><td colspan="2">model::index_out_of_bounds_exception</td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Example used for the performance test in C#</p>
<p>This shows a simple way to speed up analysis of data using the C# binding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metrics</td><td>extraction metric set </td></tr>
    <tr><td class="paramname">focus_scores</td><td>array of focus scores </td></tr>
    <tr><td class="paramname">channel</td><td>channel for focus </td></tr>
    <tr><td class="paramname">n</td><td>size of array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76e529aedb5b3470bad05be4a673cd20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t count_legacy_q_score_bins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count number of unique counts to determine number of unique bins for legacy binning</p>
<dl class="section note"><dt>Note</dt><dd>, if the number of bins is greater than 7, than this function stops counting!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of unique bins </dd></dl>

</div>
</div>
<a class="anchor" id="a02eb9928846137fea7fe46618a25ee21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::count_q_metric_bins </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of bins in the q metric</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of q_metric collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of q_metric collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bins </dd></dl>

</div>
</div>
<a class="anchor" id="a2a5f6954b2b6fc9755742598b6f8e727"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::count_q_metric_bins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of bins in the q metric</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bins </dd></dl>

</div>
</div>
<a class="anchor" id="ab171ea60888d51b26dbf1214ea22a48c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::count_q_metric_bins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of bins in the q metric</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bins </dd></dl>

</div>
</div>
<a class="anchor" id="ae441eb579cde2fc86024e389c5900fb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::count_q_metric_bins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of bins in the q metric</p>
<dl class="section note"><dt>Note</dt><dd>Always returns 0 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="a669a000cf564120ea406c24051d20995"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::count_qvals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether the q-values are compressed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of q-vals </dd></dl>

</div>
</div>
<a class="anchor" id="adeda2bde2cfde0167de9d1e7c141b71f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::count_qvals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether the q-values are compressed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>by lane q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of q-vals </dd></dl>

</div>
</div>
<a class="anchor" id="a27c85426a1e7f771f552cd19d188f7aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::count_qvals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether the q-values are compressed</p>
<dl class="section note"><dt>Note</dt><dd>This always returns 0 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a class="anchor" id="aeff702ee4fdc57b833be112716e1a4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_collapse_q_metrics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collapsed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate collapsed Q-metric data from Q-metrics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric_set</td><td>q-metric set </td></tr>
    <tr><td class="paramname">collapsed</td><td>collapsed Q-metrics </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a485f78badd31f82b9a3e1c49e77b735c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_q_metrics_by_lane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bylane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2">model::index_out_of_bounds_exception</td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate by lane Q-metric data from Q-metrics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric_set</td><td>Q-metrics </td></tr>
    <tr><td class="paramname">bylane</td><td>bylane Q-metrics </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">index_out_of_bounds_exception</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adef30dfc0ef9746b674661dff73df370"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::index_for_q_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>qval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the index for the given q-value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
    <tr><td class="paramname">qval</td><td>threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of q-val above given threshold </dd></dl>

</div>
</div>
<a class="anchor" id="a1fc9916c30d3f620c2b48dc2909905e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::index_for_q_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>qval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the index for the given q-value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>by lane q-metric set </td></tr>
    <tr><td class="paramname">qval</td><td>threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of q-val above given threshold </dd></dl>

</div>
</div>
<a class="anchor" id="a9d47a4293dccdd4cc74335faf596f063"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::metric::is_compressed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether the q-values are compressed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the histogram is compressed (no all zero columns) </dd></dl>

</div>
</div>
<a class="anchor" id="abf7512321bc0c081a8e9610bcc5631de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::metric::is_compressed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether the q-values are compressed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>collapsed q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the histogram is compressed (no all zero columns) </dd></dl>

</div>
</div>
<a class="anchor" id="ac916e8708ebdda85d212ce2631510f48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::metric::is_compressed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether the q-values are compressed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>by lane q_metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the histogram is compressed (no all zero columns) </dd></dl>

</div>
</div>
<a class="anchor" id="a5e50ecdfca3016a975969b28cfd08e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::lane_from_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert string lane/tile identifier (1_1111) to lane number</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_name</td><td>lane/tile identifier (1_1111) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lane number (1) </dd></dl>

</div>
</div>
<a class="anchor" id="ac0e0196a06bc3001748210a6d0c3fa96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::max_qval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the maximum Q-value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum Q-value </dd></dl>

</div>
</div>
<a class="anchor" id="a1739cce953b851ed2cc3b54d56afe4ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::max_qval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the maximum Q-value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>by lane q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum Q-value </dd></dl>

</div>
</div>
<a class="anchor" id="ade7fbdb67c0a6366326711706ec1c4eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::logic::metric::max_qval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the maximum Q-value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>collapsed q-metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum Q-value </dd></dl>

</div>
</div>
<a class="anchor" id="a7a6ff64f1c38a893a5abf1f7a1fa3dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::number </td>
          <td>(</td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>tile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tile number</p>
<p>Calculates the number of the tile from the tile id.</p>
<dl class="section return"><dt>Returns</dt><dd>number of the tile. </dd></dl>

</div>
</div>
<a class="anchor" id="a38b5b47daadbc0fb8f4c32ad028195d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::physical_location_column </td>
          <td>(</td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>tile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>swath_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all_surfaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the physical location (in terms of its column number) of the tile on the flow cell</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_id</td><td>tile id </td></tr>
    <tr><td class="paramname">method</td><td>tile naming method (4-digit or 5-digit or Absolute) </td></tr>
    <tr><td class="paramname">swath_count</td><td>number of swathes per lane </td></tr>
    <tr><td class="paramname">all_surfaces</td><td>if true, then find the proper column assuming all surfaces are being displayed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>physical location of the tile in terms of its column number </dd></dl>

</div>
</div>
<a class="anchor" id="a9a77c902372cc9d1333afc8575e4e3f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::physical_location_column </td>
          <td>(</td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>tile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1run_1_1flowcell__layout.html">model::run::flowcell_layout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all_surfaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the physical location (in terms of its column number) of the tile on the flow cell</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_id</td><td>tile id </td></tr>
    <tr><td class="paramname">layout</td><td>flow cell layout </td></tr>
    <tr><td class="paramname">all_surfaces</td><td>if true, then find the proper column assuming all surfaces are being displayed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>physical location of the tile in terms of its column number </dd></dl>

</div>
</div>
<a class="anchor" id="a1443cec18eab79d5a7732601adc4704c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::physical_location_row </td>
          <td>(</td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>tile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>section_per_lane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>tile_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the physical location (in terms of its row number) of the tile on the flow cell</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_id</td><td>tile id </td></tr>
    <tr><td class="paramname">method</td><td>tile naming method (4-digit or 5-digit or Absolute) </td></tr>
    <tr><td class="paramname">section_per_lane</td><td>number of sections per lane (5-digit only) </td></tr>
    <tr><td class="paramname">tile_count</td><td>number of tiles per swath </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>physical location of the tile in terms of its row number </dd></dl>

</div>
</div>
<a class="anchor" id="a04d96d83b841a2eb24dcaa846903ac5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::physical_location_row </td>
          <td>(</td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>tile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1run_1_1flowcell__layout.html">model::run::flowcell_layout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the physical location (in terms of its row number) of the tile on the flow cell</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_id</td><td>tile id </td></tr>
    <tr><td class="paramname">layout</td><td>flow cell layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>physical location of the tile in terms of its row number </dd></dl>

</div>
</div>
<a class="anchor" id="a4513418a65eaf84fc7af825475226f60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void populate_cumulative_distribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2">model::index_out_of_bounds_exception</td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate cumulative by lane q-metric distribution</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a182afdbc60e4594926178858807969ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void populate_cumulative_distribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2">model::index_out_of_bounds_exception</td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate cumulative q-metric distribution</p>
<dl class="section note"><dt>Note</dt><dd>This can exist here or in SWIG. This is a swig interface function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4436b3ce6fd74abddc7bf267fa23160e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void populate_cumulative_distribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2">model::index_out_of_bounds_exception</td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate cumulative cpllapsed q-metric distribution</p>
<dl class="section note"><dt>Note</dt><dd>This can exist here or in SWIG. This is a swig interface function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2255099000b0748948892068219a41af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::metric::populate_cumulative_distribution_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; QMetric &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_set</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2">model::index_out_of_bounds_exception</td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate cumulative q-metric distribution</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric_set</td><td>q-metric set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad706052df7c77ab706ea3329515da54d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void populate_dynamic_phasing_metrics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1phasing__metric.html">model::metrics::phasing_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>phasing_metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1summary.html#a9269802b156d7d51dfd208503d114945">logic::summary::read_cycle_vector_t</a> &amp;&#160;</td>
          <td class="paramname"><em>cycle_to_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1dynamic__phasing__metric.html">model::metrics::dynamic_phasing_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamic_phasing_metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1tile__metric.html">model::metrics::tile_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_metrics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the dynamic phasing metrics (slope &amp; offset for phasing &amp; prephasing) data structure given the phasing metrics data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phasing_metrics</td><td>phasing metric set </td></tr>
    <tr><td class="paramname">cycle_to_read</td><td>map of cycle to read information </td></tr>
    <tr><td class="paramname">dynamic_phasing_metrics</td><td>dynamic phasing metric set (to be populated) </td></tr>
    <tr><td class="paramname">tile_metrics</td><td>tile metric set (to be populated)</td></tr>
  </table>
  </dd>
</dl>
<p>Populate the dynamic phasing metrics (slope &amp; offset for phasing/prephasing) data structure given the phasing metrics data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phasing_metrics</td><td>phasing metric set </td></tr>
    <tr><td class="paramname">cycle_to_read</td><td>map of cycle to read information </td></tr>
    <tr><td class="paramname">dynamic_phasing_metrics</td><td>dynamic phasing metric set (to be populated) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8809c6f0abb67743e6933ff198b71229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void populate_legacy_q_score_bins </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__score__bin.html">model::metrics::q_score_bin</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_score_bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#a849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the q-score header bins from the data</p>
<p>This only for legacy platforms that use older q-metric formats, which do not include bin information in the header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_score_bins</td><td>vector of q-score bins </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type </td></tr>
    <tr><td class="paramname">count</td><td>number of bins </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e84b12f05bac281a4131ec493f20a51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::metric::populate_legacy_q_score_bins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__metric.html">model::metrics::q_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__score__bin.html">model::metrics::q_score_bin</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_score_bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#a849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate the q-score header bins from the data</p>
<p>This only for legacy platforms that use older q-metric formats, which do not include bin information in the header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
    <tr><td class="paramname">q_score_bins</td><td>vector of q-score bins </td></tr>
    <tr><td class="paramname">instrument</td><td>type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42335973ac805f414847152f52578996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::metric::populate_legacy_q_score_bins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__by__lane__metric.html">model::metrics::q_by_lane_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__score__bin.html">model::metrics::q_score_bin</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_score_bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#a849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate the q-score header bins from the data</p>
<p>This only for legacy platforms that use older q-metric formats, which do not include bin information in the header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
    <tr><td class="paramname">q_score_bins</td><td>vector of q-score bins </td></tr>
    <tr><td class="paramname">instrument</td><td>type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8836306d7f51a31de926e5736be98647"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::metric::populate_legacy_q_score_bins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__collapsed__metric.html">model::metrics::q_collapsed_metric</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_metric_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1model_1_1metrics_1_1q__score__bin.html">model::metrics::q_score_bin</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_score_bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#a849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate the q-score header bins from the data</p>
<p>This only for legacy platforms that use older q-metric formats, which do not include bin information in the header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_metric_set</td><td>q-metric set </td></tr>
    <tr><td class="paramname">q_score_bins</td><td>vector of q-score bins </td></tr>
    <tr><td class="paramname">instrument</td><td>type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3d25d41b66e91ee21b67901188747d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::metric::requires_legacy_bins </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if legacy binning should be performed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of bins </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if determining the bins is required </dd></dl>

</div>
</div>
<a class="anchor" id="ab1c968c5fbff5bbcf12c937010cd4689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::section </td>
          <td>(</td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>tile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a>&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Section number</p>
<p>Calculates the section of the tile from the tile id.</p>
<dl class="section return"><dt>Returns</dt><dd>section of the tile. </dd></dl>

</div>
</div>
<a class="anchor" id="a3de62d8ac1f534d0ac2ebcbc8eb3d0db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::surface </td>
          <td>(</td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>tile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a>&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surface number</p>
<p>Calculates the surface of the tile from the tile id.</p>
<dl class="section return"><dt>Returns</dt><dd>surface of the tile. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bb768910f86a9090a16bbc525c0ec7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::swath </td>
          <td>(</td>
          <td class="paramtype">const ::uint32_t&#160;</td>
          <td class="paramname"><em>tile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a>&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swath number</p>
<p>Calculates the surface of the tile from the tile id.</p>
<dl class="section return"><dt>Returns</dt><dd>surface of the tile. </dd></dl>

</div>
</div>
<a class="anchor" id="abbbc3869d286655f0dc2c90fb2d85b04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::uint32_t illumina::interop::logic::metric::tile_from_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tile_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert string lane/tile identifier (1_1111) to tile hash</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_name</td><td>lane/tile identifier (1_1111) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tile hash (1111) </dd></dl>

</div>
</div>
<a class="anchor" id="ab0664b929bb0697936655810a334a8ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a> illumina::interop::logic::metric::tile_naming_method_from_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1base__metric.html">model::metric_base::base_metric</a> &amp;&#160;</td>
          <td class="paramname"><em>metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the tile naming method from a metric tile ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric</td><td>tile metric </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tile_naming_method </dd></dl>

</div>
</div>
<a class="anchor" id="ad9d22d75ec1c26ebca73989574196a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceillumina_1_1interop_1_1constants.html#aeeb74679b93b0aa6362a9b989560cf9f">constants::tile_naming_method</a> illumina::interop::logic::metric::tile_naming_method_from_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classillumina_1_1interop_1_1model_1_1metric__base_1_1metric__set.html">model::metric_base::metric_set</a>&lt; Metric &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the tile naming method from a metric set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric_set</td><td>metric set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tile_naming_method </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
